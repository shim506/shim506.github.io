# 정리 & 학습 필요 주제
1. 

# 2일
### SQL
- 원래는 아래와 같이 SQL 1과 같이 작성해야하지만 JAVA 코드에서 바인딩 변수를 사용할때 ? 를 사용할 수 있음
  - INSERT INTO 테이블명 (컬럼1, 컬럼2, ...) VALUES (값1, 값2, ...);
  -  "insert into member(member_id, money), values (?,?)";

# 3일
### 코딩테스트
- 문제에서 제시된 사례 내용은 설명과 함께 한번 따라가 보는 것이 좋음
- 이중 람다를 써야하는 상황에서 it 에 혼용으로 인한 오류 가능성이 있으니 변수를 명시해주는 것을 잊지말자
- 문제 안에서 이미 정렬된 리스트가 주어졌을때는 이를 활용할 수 있느 방법을 생각해보자
- Map 구체 활용법
  - getOrDefault 를 활용하여 조건문을 줄일 수있따
    - cntMap[team] = cntMap.getOrDefault(team , 0 ) + 1
  - 리스트에 대해서는 apply 연산자를 이용하여 리스트를 반환하면 깔끔하다
    - scoreMap[ele] = scoreMap.getOrDefault(ele ,mutableListOf()).apply { add(score) }
- 복잡한 정렬 조건
  - 간단한 정렬른 sortBy{} 를 활용하고, 복잡한 정렬에 대해서는 compareBy 와 함게 sortedWith 를 사용하는 것이 좋음
  - 다중 정렬 기준을 적용하는데 특히 효과적
    - ex) val sortedList = sumMap.toList().sortedWith(compareBy({ it.second }, { fifthMap[it.first] }))
- 리스트 vs 배열
  - 만약 인덱스 저장이 필요하고 자료의 길이를 고정해놓는 것이 필요하다면 배열을 사용하는 것이 효고적이다
  - 리스트의 경우 인덱스 값까지 Pair 로 저장하거나 빈 값을 넣어 두어야하는 방식이기에 이 케이스에서의 리스트 장점이 사라진다
  
![img.png](img.png)

- 텍스트로 된 문제를 그림으로 도식화해보자 -> 포문과 이프문을 머릿속으로 그리고 치기전에 실제 값들을 대입하여 써서 개산해보는 과정

# 4일
## Spring
### JDBC 등장이유
- 각 DB 마다 커넥션 SQL 전달 방법, 결과 응답 받는 방법들이 상이했음
- DB 를 교체할때마 이에 따른 코드가 수정 되어야하고, 각 방법을 새로 학습해야했음
- 해결점: 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API 즉 JDBC 를 통해 이를 해결
- 한계: 여전히 각 DB 마다의 SQL 작성법이 상이하다( JPA 를 통해 이 문제도 해결 가능) 

- SQL injection 공격을 예방하려면 PreparedStatement 를 통한 파라미터 바인딩 방식을 사용

# 5일
## Spring
### 커넥션 풀
- 커넥션을 새롭게 만드는 과정이 매우 복잡하고 소모적임(예외처리 부터에서 아주 귀찮) + 속도에 영향을 주기도함
- 이를 해결하기 귕해 미리 커넥션을 생성해두었다가 사용하는 개념이 커넥션 풀임 (이미 TCP/IP 로 DB 와 컨넥션이 연결되어 있음)

### 데이터소스
- 커넥션을 얻는 방법에 있어서 JDBC DriverManager 를 직접 사용하거나 커넥션풀들(커넥션 풀에 대한 여러 구현체들)을 사용할 수 있음
- 사용처를 바꿀때 의존 코드의 수정을 최소화하고자 커넥션을 획득하는 방법을 추상화 한것이 `데이터 소스`

## 클린코드
### 변수
- 변수명은 지나치게 줄이기보다는 분명하게 나타내는 것이 좋음
- 사용하는 부분에 최대한 가깝게 생성
- 사용하는 범위를 고려하여 변수가 될지 상수가 될지를 결정(객체더라도 불변이라면 상수로 선언하는 것이 좋을 수 있음)

### 메서드
- 한 메서드의 주제는 반드시 하나다 -> 하나 이상에 테스크를 수행한다면 쪼개라
- 반환할 만한 값이 있느지 고민해조기 -> 테스트에 용이 함

### 기타
- 매직 넘버, 매직스트링은 지양한다

### 조건문
- early return
  - 미리 탈출이 가능하다면 탈출 시킴으로써 굳이 아래까지 코드를 읽을 필요가 없게 함 -> else 문 없어짐
  - if 문 중첩을 없앨 수 있다 
  - 다만 탈출 코드가 중구 난방이 될 경우 가독성을 해칠 수 있기때문에 조절 할 수 있다면 최대한 탈출 코드를 응집 시키는 것이 좋겠다
- 변수 값에 대한 검사라면 if 문 대신 when 을 사용하는 것이 가독성면에서 낫다

### 반복문
- 중첩문 안에서 메서드로 쪼개는 것을 고려해보자
  - 메서드로 쪼개게 되면 메서드 내부와 파라미터의 영역만에 온전히 집중할 수 있게된다
  - 쪼개는 것이 가독성을 높이질에 대해서는 생각해보기

### 부정연산자
- 불필요한 부정연산자는 피하자
- 메서드를 통해 부정연산자를 없애는 방식도 고려해보자(isNot 키워드를 넣거나 반대 개념 ex- Left/Right)

### 객체 설계
- 무지성으로 getter/setter 를 설정하지 않아야한다
- setter
  - 객체 내부에서 외부 개입없이 자체적인 변경/가곡으로 처리할 수 있는지를 확인
  - 만약 외부에서 가기고 있는 데이터로 변경이 필요한경우 set~ 보다는 update 와 같이 의도를 드러내는 네이밍을 고려해볼 수 있음
- getter
  - 해당 필드가 외부로 그대로의 노출이 꼭 필요한지는 고민해볼 필요가 있음
  - person.get지갑().get신분증().age > = 19 보다는 person.isAgeGreaterThanOrEqualTo(19) 가 나은 구현
- 필드
  - 불필요한 필드를 굳이 만들 필요없음
  - 필드 A 를 가지고 계산할 수 있는 기능

# 6일
## 코테
- 반복문에서의 요소 삭제
  - for 문 안에서 해당 리스트에 대한 삭제는 지양해야한다
  - 루프 중간에 요소가 삭제되면 리스트의 인덱스가 조정되지 않고 다음 요소로 뛰는 문제가 발생
- 시간복잡도
  - 시간 복잡도 안에서 해결하려고 노력하고 그 이상에 효율을 위해서 지나친 노력을 하지 말자
  - 특히 코드의 복잡도를 높이는 것은 금물
- 반복문 탈출
  - repeat 내부에서는`return@repeat`를 통해서 탈출 할 수 있다
  - return 을 할 경우 현재 반복문과 가장 가까운 스콥으로 탈출하게 된다

## Spring
### 트렌잭션
- sql 에 대해서 commit 을 하기 전까지는 임시로 데이터를 저장하는 것
  - 커밋하기 전 내용은 다른 세션에서는 확인 할 수 없음

# 7일
## Spring

### DB 락
- 세션이 트랜젝션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백전까지 다른 세션에서 해당 데이터를 수정할 수 없게 막아야한다
- `SET LOCK_TIMEOUT <mSec>` 를 쿼리와함께 명시하는 부분이 이미 점유된 락을 기다리게됨 -> 기존에 점유권을 얻은 곳에서 방어하는 것x , 침범하지 않기위한 설정 O
- `select for update` 를 사용하면 기존 점유권을 얻은 쪽에서 락을 가져가고 다른 세션에서의 조회/업데이트까지도 막을 수 있음  (ex-`select * from member where member_id='A' for update;`)

### 트렌젝션 적용
- 트렌젝션은 한개의 세션안에서 이루어져야하기 때문에 Connection 객체를 공유하고 중간에 연결을 끊지 않도록 한다
- con.setAutocommit 이 사실상 트렌젝션에 시작임
- 트렌젝션 종료 시점(finally~) 에는 autoCommit 을 디폴트값인 true 로 복구한다

### Application 구조 
- 프레젠테이션 계층(@Controller) -> 서비스 계층(@Service) -> 데이터 계층(@Repository) -> DB 서버